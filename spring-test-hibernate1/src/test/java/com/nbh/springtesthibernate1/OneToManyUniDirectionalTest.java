package com.nbh.springtesthibernate1;

import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
import org.springframework.test.context.junit4.SpringRunner;

/**
 * Wow!
 * This uses just the parent to keep the relationship upto date.
 * It creates a Join table to perform the relationship-
 *
 * Hibernate: create table engine (id bigint generated by default as identity, name varchar(255), primary key (id))
 * Hibernate: create table engine_parts (engine_id bigint not null, parts_id bigint not null)
 * Hibernate: create table part (id bigint generated by default as identity, name varchar(255), primary key (id))
 *
 *
 */
@RunWith(SpringRunner.class)
@DataJpaTest
public class OneToManyUniDirectionalTest {


    @Autowired
    TestEntityManager entityManager;

    @Test
    public void showAddingAndRemovingPartsOfAnEngine(){

        Engine engine = new Engine("VeeEightTurbo");
        engine = entityManager.persistAndFlush(engine);

        /*Hibernate: insert into engine (id, name) values (null, ?)
        binding parameter [1] as [VARCHAR] - [VeeEightTurbo]*/


        Part oilPump= new Part("Oil Pump");
        entityManager.persist(oilPump);
        /*Hibernate: insert into part (id, name) values (null, ?)
        binding parameter [1] as [VARCHAR] - [Oil Pump] etc*/
        engine.addPart(oilPump);
        Part part = new Part("SparkPlugs");
        entityManager.persist(part);
        engine.addPart(part);
        part = new Part("Crankshaft");
        entityManager.persist(part);
        engine.addPart(part);
        entityManager.persistAndFlush(engine);
        // adds the relationship in the engine-parts table.
        /*Hibernate: insert into engine_parts (engine_id, parts_id) values (?, ?)
binding parameter [1] as [BIGINT] - [1]
binding parameter [2] as [BIGINT] - [1]*/

        Engine e1 = entityManager.find(Engine.class, engine.id);
        for (Part p1 : e1.getParts()){
            System.out.println(p1.name);
        }

        e1.removePart(oilPump);
        entityManager.persistAndFlush(e1);

        /*
        A delete will remove ALL entries from the Engine (parent side)
        Then re-add the remaining ones back in to the mapping table..
        * Hibernate: delete from engine_parts where engine_id=?
binding parameter [1] as [BIGINT] - [1]
Hibernate: insert into engine_parts (engine_id, parts_id) values (?, ?)
binding parameter [1] as [BIGINT] - [1]
binding parameter [2] as [BIGINT] - [2]
Hibernate: insert into engine_parts (engine_id, parts_id) values (?, ?)
binding parameter [1] as [BIGINT] - [1]
binding parameter [2] as [BIGINT] - [3]*/

        //lets see if we can delete a part off...
        //entityManager.remove(part);
        //entityManager.flush();

        /* Fails with-
        Hibernate: delete from part where id=?
binding parameter [1] as [BIGINT] - [3]
SQL Error: 23503, SQLState: 23503
Referential integrity constraint violation: "FKF5CF01P9GLE0IDYRCEPR3MIOW: PUBLIC.ENGINE_PARTS FOREIGN KEY(PARTS_ID) REFERENCES PUBLIC.PART(ID) (3)"; SQL statement:
delete from part where id=? [23503-196]
HHH000010: On release of batch it still contained JDBC statements
        * */
    }
}