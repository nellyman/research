package com.nbh.relationships.onetomany;

import com.nbh.relationships.onetomany.model.JetEngine;
import com.nbh.relationships.onetomany.model.JetPart;
import com.nbh.relationships.onetomany.repos.PartRepo;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;
import org.springframework.boot.test.autoconfigure.orm.jpa.TestEntityManager;
import org.springframework.test.context.junit4.SpringRunner;


/**
 * As a join column is used there is no mapping table required-
 * Hibernate: create table jet_engine (id bigint generated by default as identity, name varchar(255), primary key (id))
  Hibernate: create table jet_part (id bigint generated by default as identity, name varchar(255), engine_id bigint, primary key (id))

 Still is more inefficient that a bidirectional mapping
 *
 */
@RunWith(SpringRunner.class)
@DataJpaTest
public class OneToManyJoinColumnTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private PartRepo partRepo;

    @Test
    public void showAddingAndRemovingOfChildEntries(){
        JetEngine engine = new JetEngine("F100");
        entityManager.persistAndFlush(engine);
        engine.addPart(new JetPart("pump1"));
        engine.addPart(new JetPart("pump2"));
        engine.addPart(new JetPart("pump3"));
        engine.addPart(new JetPart("fans"));
        engine.addPart(new JetPart("compressor"));
        entityManager.persistAndFlush(engine);

        /**
         Hibernate: insert into jet_engine (id, name) values (null, ?)
         binding parameter [1] as [VARCHAR] - [F100]
         Hibernate: insert into jet_part (id, name) values (null, ?)
         binding parameter [1] as [VARCHAR] - [pump1]
         Hibernate: insert into jet_part (id, name) values (null, ?)
         binding parameter [1] as [VARCHAR] - [pump2]
         ...
         (The following updates make this relationship still not as efficient as the bidirectional mapping)
         (The child entries are updated to map to the parent...)
         Hibernate: update jet_part set engine_id=? where id=?
         binding parameter [1] as [BIGINT] - [1]
         binding parameter [2] as [BIGINT] - [1]
         Hibernate: update jet_part set engine_id=? where id=?
         binding parameter [1] as [BIGINT] - [1]
         binding parameter [2] as [BIGINT] - [2]
         ....
         */

        // lets remove a part....
        JetPart pump2 = partRepo.findByName("pump2");
        engine.removePart(pump2);
        entityManager.persistAndFlush(engine);

        /**
         * The above...
         * find pimp2-
         * Hibernate: select jetpart0_.id as id1_6_, jetpart0_.name as name2_6_ from jet_part jetpart0_ where jetpart0_.name=?
         binding parameter [1] as [VARCHAR] - [pump2]
         extracted value ([id1_6_] : [BIGINT]) - [2]
         set the maping to null-
         Hibernate: update jet_part set engine_id=null where engine_id=? and id=?
         binding parameter [1] as [BIGINT] - [1]
         binding parameter [2] as [BIGINT] - [2]
         remove the JetPart-
         Hibernate: delete from jet_part where id=?
         binding parameter [1] as [BIGINT] - [2]
         */

    }

}